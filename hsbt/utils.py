import os
import zipfile
import requests
from pathlib import Path, PurePath
from typing import Union, List, BinaryIO, Dict
import subprocess
import logging

log = logging.getLogger(__name__)


def download_file(
    url: str, target: Union[str, Path, BinaryIO]
) -> Union[Path, BinaryIO]:
    close_file_obj = True
    final_target_path = None
    if isinstance(target, str):
        target = Path(str)
    if isinstance(target, Path):
        if target.is_dir():
            local_filename = url.split("/")[-1]
            target = Path(PurePath(target, local_filename))
        final_target_path = target
        target = open(target, "wb")
    else:
        close_file_obj = False

    with requests.get(url, stream=True) as r:
        r.raise_for_status()
        for chunk in r.iter_content(chunk_size=8192):
            target.write(chunk)
    if close_file_obj:
        close_file_obj.close()
        return final_target_path
    return target


def unzip_file(zip_file: Union[str, Path, BinaryIO], target_dir: Path):
    with zipfile.ZipFile(zip_file, "r") as zip_ref:
        zip_ref.extractall(target_dir)


def run_command(
    command: Union[List[str], str],
    extra_envs: Dict[str, str] = None,
):
    if extra_envs is None:
        extra_envs = {}
    if isinstance(command, str):
        command = [command]
    command = ["/bin/bash", "-c"] + command

    # print("comamnd:", type(command), command)
    # print("RUN#:", " ".join(command))
    current_env: Dict[str, str] = os.environ.copy()
    log.debug(f"RUN COMMAND: {' '.join(command)}")
    proc = subprocess.run(
        command, capture_output=True, text=True, env=current_env | extra_envs
    )
    if proc.stderr:
        e_msg = (
            f"Command '{command}'. ErrorCode: {proc.returncode} Error:\n{proc.stderr}"
        )
        # log.error(e_msg)
        raise ChildProcessError(
            e_msg,
            proc.returncode,
        )
    log.debug(f"COMMAND RESULT: {proc.stdout}")
    return proc.stdout


def convert_df_output_to_dict(df_output):
    lines = df_output.strip().split("\n")
    headers = lines[0].split()
    devices = []

    for line in lines[1:]:
        values = line.split()
        device = dict(zip(headers, values))
        devices.append(device)
    return devices


class ConfigEntryExistsError(Exception):
    pass


class ConfigFileEditor:
    def __init__(
        self,
        target_file: Union[str, Path],
        base_identifier: str = "",
        line_comment_line_delimiter: str = "#",
        source_hint: str = "CONFIG LINES GENERATED BY HSBT SCRIPT",
        create_file_if_not_exists: bool = True,
        create_mode: int = 0o660,
    ):
        if isinstance(target_file, str):
            target_file = Path(target_file)
        self.target_file = target_file
        self.line_comment_line_delimiter = line_comment_line_delimiter
        self.base_identifier = base_identifier
        self.source_hint = source_hint
        self.create_file_if_not_exists = create_file_if_not_exists
        self.create_mode = create_mode

    def validate_and_prepare_target(self):
        if self.target_file.is_dir():
            raise ValueError(
                f"Target file {self.target_file} is directory. Expected file."
            )
        elif self.target_file.is_file():
            if not os.access(self.target_file, os.W_OK):
                raise ValueError(f"Target file {self.target_file} is not writable.")
        elif not self.target_file.exists() and self.create_file_if_not_exists:
            self.target_file.parent.mkdir(exist_ok=True, parents=True, mode=551)
            self.target_file.touch(mode=self.create_mode)
        elif not self.target_file.exists() and not self.create_file_if_not_exists:
            raise ValueError(f"Target file {self.target_file} does not exist.")

    def create_config_entry(
        self,
        content: Union[str, List[str]],
        identifier: str,
        overwrite_entry_if_exists: bool = False,
        entry_exists_ok: bool = False,
    ):
        self.validate_and_prepare_target()
        if isinstance(content, str):
            content = [content]
        start_delimiter: str = f"{self.line_comment_line_delimiter} <{self.source_hint} '{self.base_identifier}/{identifier}'>"

        end_delimiter: str = f"{self.line_comment_line_delimiter} </{self.source_hint} '{self.base_identifier}/{identifier}'>"
        config_file_lines: List[str] = []
        if self.target_file.exists:
            with open(self.target_file, "r") as file:
                for line in file.readlines():
                    config_file_lines.append(line.strip("\n"))
        record_stop: bool = False
        updated_existing: bool = False
        new_config_file_lines: List[str] = []
        for line in config_file_lines:
            if line == start_delimiter and overwrite_entry_if_exists:
                record_stop = True
                updated_existing = True
                new_config_file_lines.append(line.strip("\n"))
                new_config_file_lines.extend(content)
            elif (
                line == start_delimiter
                and not overwrite_entry_if_exists
                and not entry_exists_ok
            ):
                raise ConfigEntryExistsError(
                    f"Config entry in file '{self.target_file}' with identifier '{start_delimiter}' exists."
                )
            if line == end_delimiter:
                record_stop = False
            if not record_stop:
                new_config_file_lines.append(line)
        if not updated_existing:
            new_config_file_lines.append(start_delimiter)
            new_config_file_lines.extend(content)
            new_config_file_lines.append(end_delimiter)

        with open(self.target_file, "w") as file:
            file.writelines(line + "\n" for line in new_config_file_lines)


test = ConfigFileEditor("./test.config")
# test.create_config_entry("hello=2\nhello_line4", "MY ENTRY", True)
